<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sticky Hero Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* Reset-ish */
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      line-height: 1.5;
      color: #111;
      background: #f4f4f4;
    }

    /* Layout wrapper (optional, just for centering content) */
    .page {
      min-height: 100vh;
    }

    /* HERO
       - Hero uses position: fixed to stay pinned at the top
       - Height is dynamic based on content
       - JavaScript measures height and sets --hero-height CSS variable
    */
    .hero {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 1; /* BELOW content; content will use z-index: 2 */
      background: radial-gradient(circle at top, #333, #000);
      color: #fff;
      padding: 4rem 1.5rem 6rem;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
    }

    .hero-kicker {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.75rem;
      opacity: 0.7;
      margin-bottom: 0.75rem;
    }

    .hero-title {
      font-size: clamp(2.5rem, 5vw, 3.5rem);
      margin: 0 0 1rem;
    }

    .hero-description {
      max-width: 42rem;
      margin: 0 0 2rem;
      font-size: 1rem;
      opacity: 0.9;
    }

    .hero-cta {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1.25rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.35);
      color: #fff;
      text-decoration: none;
      font-size: 0.9rem;
      backdrop-filter: blur(6px);
    }

    .hero-cta span {
      font-size: 1.2rem;
      line-height: 1;
    }

    /* PAGE CONTENT
       - Relative with higher z-index so it scrolls over the hero.
       - Uses --hero-height CSS variable set by JavaScript for margin-top
    */
    .page-content {
      position: relative;
      z-index: 2;
      margin-top: var(--hero-height, 100vh); /* Fallback to 100vh if JS hasn't run */
      background: #fff;
      box-shadow: 0 -16px 40px rgba(0, 0, 0, 0.4);
    }

    .page-section {
      padding: 4rem 1.5rem;
      max-width: 60rem;
      margin: 0 auto;
      border-bottom: 1px solid #eee;
    }

    .page-section h2 {
      margin-top: 0;
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }

    .page-section p {
      margin: 0 0 1rem;
      color: #333;
    }

    .page-section:last-of-type {
      border-bottom: none;
      padding-bottom: 5rem;
    }

    /* Just to make the scroll obvious */
    .filler {
      height: 40vh;
      background: repeating-linear-gradient(
        -45deg,
        #fafafa,
        #fafafa 10px,
        #f0f0f0 10px,
        #f0f0f0 20px
      );
      border-radius: 0.75rem;
      margin-top: 1.5rem;
    }
  </style>
</head>
<body>
  <div class="page">
    <!-- HERO -->
    <header class="hero">
      <div class="hero-kicker">Fixed Hero Demo</div>
      <h1 class="hero-title">A Fixed Hero with Dynamic Height</h1>

      <p class="hero-description">
        This hero uses <code>position: fixed</code> to stay pinned at the top
        while content scrolls over it. JavaScript measures the hero's actual height
        and sets a CSS custom property (<code>--hero-height</code>) which is used
        as <code>margin-top</code> on the content below. This allows the hero to
        have dynamic height based on its content while keeping everything properly positioned.
      </p>

      <p class="hero-description">
        Try adding or removing text here and resizing the window - the layout
        will automatically adjust without any hard-coded heights!
      </p>

      <a href="#section-1" class="hero-cta">
        Jump to content
        <span>â†“</span>
      </a>
    </header>

    <!-- PAGE CONTENT -->
    <main class="page-content">
      <section class="page-section" id="section-1">
        <h2>Section 1: How It Works</h2>
        <p>
          Scroll down and watch how this content passes over the hero. The hero
          uses <code>position: fixed</code> to stay pinned at the top, while this
          content has a <code>margin-top</code> equal to the hero's dynamic height.
        </p>
        <p>
          The <code>margin-top</code> is set using a CSS custom property
          (<code>--hero-height</code>) that JavaScript updates whenever the hero's
          height changes. This means you can add or remove content from the hero
          and the layout will automatically adjust - no hard-coded values needed!
        </p>
        <p>
          Open the browser console to see the hero height being calculated and
          updated in real-time.
        </p>
        <div class="filler"></div>
      </section>

      <section class="page-section">
        <h2>Section 2: Technical Implementation</h2>
        <p>
          This approach uses three key techniques:
        </p>
        <ul>
          <li><strong>CSS Custom Property:</strong> The <code>--hero-height</code> variable is set on the document root and used in the CSS.</li>
          <li><strong>ResizeObserver:</strong> Automatically detects when the hero's size changes (content added/removed, font loads, etc.).</li>
          <li><strong>Z-index layering:</strong> Hero at <code>z-index: 1</code>, content at <code>z-index: 2</code> so it scrolls over the hero.</li>
        </ul>
        <p>
          This is more reliable than <code>position: sticky</code> when you need
          the hero to remain pinned indefinitely and have dynamic height.
        </p>
        <div class="filler"></div>
      </section>

      <section class="page-section">
        <h2>Section 3: Testing Dynamic Height</h2>
        <p>
          Try these tests to see the dynamic height in action:
        </p>
        <ul>
          <li>Open your browser's DevTools and edit the hero text directly in the DOM</li>
          <li>Resize the browser window to see the height recalculate</li>
          <li>Check the console to see the height updates being logged</li>
        </ul>
        <p>
          The layout will automatically adjust without needing to refresh the page
          or recalculate any hard-coded values. This makes it perfect for dynamic
          content scenarios like CMS-driven hero sections.
        </p>
        <div class="filler"></div>
      </section>
    </main>
  </div>

  <script>
    /**
     * Technical Approach:
     * 1. Measure the hero element's actual height using getBoundingClientRect()
     * 2. Set a CSS custom property (--hero-height) on the document root
     * 3. The .page-content uses this variable for its margin-top
     * 4. Listen for resize events to recalculate when window size changes
     * 5. Use ResizeObserver to detect when hero content changes dynamically
     */

    function updateHeroHeight() {
      const hero = document.querySelector('.hero');
      if (!hero) return;

      // Measure the actual height of the hero
      const heroHeight = hero.getBoundingClientRect().height;

      // Set the CSS custom property on the document root
      document.documentElement.style.setProperty('--hero-height', `${heroHeight}px`);

      console.log(`Hero height updated: ${heroHeight}px`);
    }

    // Run on initial load
    updateHeroHeight();

    // Update on window resize
    window.addEventListener('resize', updateHeroHeight);

    // Use ResizeObserver to detect when hero content changes
    // (e.g., if text is added/removed dynamically, or fonts load)
    if ('ResizeObserver' in window) {
      const hero = document.querySelector('.hero');
      const resizeObserver = new ResizeObserver(updateHeroHeight);
      resizeObserver.observe(hero);
    }

    // Also run after fonts are loaded (in case font loading changes height)
    if (document.fonts && document.fonts.ready) {
      document.fonts.ready.then(updateHeroHeight);
    }
  </script>
</body>
</html>